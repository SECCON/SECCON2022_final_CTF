from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Util.number import long_to_bytes


p = 234687789984662131107323206406195107369
a = 35686285754866388325178539790367732387
b = 36011211474181220344603698726947017489
c = 84664322357902232989540976252462702046
d = 154807718022294938130158404283942212610
outs = [222378874028969090293268624578715626424, 42182082074667038745014860626841402403, 217744703567906139265663577111207633608]
iv = 0xf2dd287ca870eb9908bf52c44dfd9d2b
ct = 0x236a6aca059ae29056a23f5458c644abb74640d672dba1ee049eb956e629b7afb03ae33b2b2b419c24197d33baf6d88e2f0eedfa90c06e1a2be18b2fae2270f05ce39de5e0d59bb9a442d1b3eb392658e45cf721094543b13d35df8cf9ce420c
iv = long_to_bytes(iv)
ct = long_to_bytes(ct)

# ======================== solve ========================
K = GF(p)

x0,x1,x2,x3 = [var(f"x{i}") for i in range(4)]
varxs = [x0, x1, x2, x3]
# A = var("a")
# B = var("b")
# C = var("c")
# D = var("d")
E = var("e")
A = a
B = b
C = c
D = d
x4 = A*x0 + B*x1 + C*x2 + D*x3 + E
x5 = A*x1 + B*x2 + C*x3 + D*x4 + E
x6 = A*x2 + B*x3 + C*x4 + D*x5 + E

# print(x4)
# print(x4.list(x0)[1])
# print(x4.list(x1)[1])
# print(x4.list(x2)[1])
# print(x4.list(x3)[1])
# print(x4.list(x0)[0].list(x1)[0].list(x2)[0].list(x3)[0])
# print("====================================")
# print(x5)
# print(x5.list(x0)[1])
# print(x5.list(x1)[1])
# print(x5.list(x2)[1])
# print(x5.list(x3)[1])
# print(x5.list(x0)[0].list(x1)[0].list(x2)[0].list(x3)[0])
# print("====================================")
# print(x6)
# print(x6.list(x0)[1])
# print(x6.list(x1)[1])
# print(x6.list(x2)[1])
# print(x6.list(x3)[1])
# print(x6.list(x0)[0].list(x1)[0].list(x2)[0].list(x3)[0])

# print("====================================")

o4 = outs[0]
o5 = outs[1]
o6 = outs[2]

f1 = x5 - (D+1)*x4
coeffs1 = [K(f1.coefficient(v)) for v in varxs]
y1 = (o5 - (D+1)*o4) % p
f2 = x6 - (D^2+C+D+1)*x4
coeffs2 = [K(f2.coefficient(v)) for v in varxs]
y2 = (o6 - (D^2+C+D+1)*o4) % p
f3 = x6 - x5 - (D^2+C)*x4
coeffs3 = [K(f3.coefficient(v)) for v in varxs]
y3 = (o6 - o5 - (D^2+C)*o4) % p


# y_i = sum(c_i*x for c_i, x in zip(coeff_i, xs)) mod p
# x_i < bound
def solve_isis(ys, coeffs, p, bound):
    assert len(ys) == len(coeffs)
    n = len(ys)
    m = len(coeffs[0])
    size = n+m
    L = [
        [0 for _ in range(size)] for _ in range(size)
    ]
    for i in range(n):
        L[i][i] = p

    for i in range(m-1):
        L[n+i][n+i] = 1

    L[-1][-1] = bound

    # multiply inverse of a_i (the coeffient of x_1)
    for i, (y, coeff) in enumerate(zip(ys, coeffs)):
        a_inv = coeff[0]^-1
        constant = y*a_inv 
        _coeff = [-v * a_inv for v in coeff][1:] + [constant]

        for j, x in enumerate(_coeff):
            L[j+n][i] = int(x)

    # unintented check
    # _L = matrix(ZZ, L)
    # for b in _L.LLL():
    #     if abs(b[-1]) == bound and b[0] == b[1] == b[2]:
    #         for x in b:
    #             print(abs(x))


    # intented solution (enumeration)
    from fpylll import IntegerMatrix, LLL
    from fpylll.fplll.gso import MatGSO
    from fpylll.fplll.enumeration import Enumeration

    sols = []

    A = IntegerMatrix.from_matrix(L)
    LLL.reduction(A)
    M = MatGSO(A)
    M.update_gso()

    sol_cnt = 3000
    enum = Enumeration(M, sol_cnt)
    answers = enum.enumerate(0, size, (size * bound**2), 0, pruning=None)

    for _, s in answers:
        v = IntegerMatrix.from_iterable(1, A.nrows, map(int, s))
        sv = v * A

        if abs(sv[0, size-1]) == bound:
            sig = 1 if sv[0, size-1] == bound else -1
            sv = [sig*x for x in sv[0]]
            valid = True
            for x in sv:
                if x < 0:
                    valid = False
                    break
            if not valid:
                continue

            if len(set(sv[:n])) != 1:
                continue

            sols.append([sv[0]] + sv[n:-1])

    return sols

candidates = solve_isis([y1, y2, y3], [coeffs1, coeffs2, coeffs3], p, 2^64)
for v in candidates:
    key = 0
    for x in v:
        key <<= 64
        key += x
    key = int(key).to_bytes(32, "little")
    cipher = AES.new(key, AES.MODE_CBC, iv)
    pt = cipher.decrypt(ct)
    valid_flag = True
    for _c in pt:
        if _c > 0x7f:
            valid_flag = False
            break

    if valid_flag:
        print(unpad(pt, 16).decode())
        # print(v)
        break
